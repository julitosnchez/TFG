import rospy

from baxter_pykdl import baxter_kinematics
import baxter_interface
import time


def main():
    rospy.init_node('baxter_kinematics')
    print '*** Baxter PyKDL Kinematics ***\n'
    kin = baxter_kinematics('left')
    limb = baxter_interface.Limb('left')

    n_mov = 32
    # FK Position
    limb.move_to_neutral()
    kp = kin.forward_position_kinematics() 

    limite_inferior_y = -0.6
    limite_inferior_z = -0.8

#    pos = [kp[0],kp[1]+limite_inferior_y,kp[2]]
#    rot = [kp[3],kp[4],kp[5],kp[6]]
#    l = kin.inverse_kinematics(pos, rot)
#    m = {'left_w0': l[4], 'left_w1': l[5], 'left_w2': l[6], 'left_e0': l[2], 'left_e1': l[3], 'left_s0': l[0], 'left_s1': l[1]}
#    limb.move_to_joint_positions(m)

    proporcionY = -1.5/n_mov
    proporcionZ = limite_inferior_z/n_mov

    for i in range(n_mov):
       kp = kin.forward_position_kinematics()
       if i < n_mov//2: 
       	pos = [kp[0],kp[1]+proporcionY,kp[2]-proporcionZ]
       else:
       	pos = [kp[0],kp[1]+proporcionY,kp[2]+proporcionZ]
       rot = [kp[3],kp[4],kp[5],kp[6]]
       l = kin.inverse_kinematics(pos, rot)
       m = {'left_w0': l[4], 'left_w1': l[5], 'left_w2': l[6], 'left_e0': l[2], 'left_e1': l[3], 'left_s0': l[0], 'left_s1': l[1]}
       limb.move_to_joint_positions(m,0.3)

    for i in range(n_mov):
       kp = kin.forward_position_kinematics()
       if i < n_mov//2: 
       	pos = [kp[0],kp[1]-proporcionY,kp[2]+proporcionZ]
       else:
       	pos = [kp[0],kp[1]-proporcionY,kp[2]-proporcionZ]
       rot = [kp[3],kp[4],kp[5],kp[6]]
       l = kin.inverse_kinematics(pos, rot)
       m = {'left_w0': l[4], 'left_w1': l[5], 'left_w2': l[6], 'left_e0': l[2], 'left_e1': l[3], 'left_s0': l[0], 'left_s1': l[1]}
       limb.move_to_joint_positions(m,0.3)



    #print kin.inverse_kinematics(pos)  # position, don't care orientation
    #print '\n*** Baxter Pose IK ***\n'  # position & orientation

    #l2 = kin.inverse_kinematics(pos2,rot)
    #l3 = kin.inverse_kinematics(pos3,rot)
    #l4 =  kin.inverse_kinematics(pos4,rot)
    #l5 =  kin.inverse_kinematics(pos5,rot)
    #l6 =  kin.inverse_kinematics(pos6,rot)
    #print  l
    #print l2
    
    #n =  {'left_w0': l2[4], 'left_w1': l2[5], 'left_w2': l2[6], 'left_e0': l2[2], 'left_e1': l2[3], 'left_s0': l2[0], 'left_s1': l2[1]}
    #r = {'left_w0': l3[4], 'left_w1': l3[5], 'left_w2': l3[6], 'left_e0': l3[2], 'left_e1': l3[3], 'left_s0': l3[0], 'left_s1': l3[1]}
    #s = {'left_w0': l4[4], 'left_w1': l4[5], 'left_w2': l4[6], 'left_e0': l4[2], 'left_e1': l4[3], 'left_s0': l4[0], 'left_s1': l4[1]}
    #t = {'left_w0': l5[4], 'left_w1': l5[5], 'left_w2': l5[6], 'left_e0': l5[2], 'left_e1': l5[3], 'left_s0': l5[0], 'left_s1': l5[1]}
    #u = {'left_w0': l6[4], 'left_w1': l6[5], 'left_w2': l6[6], 'left_e0': l6[2], 'left_e1': l6[3], 'left_s0': l6[0], 'left_s1': l6[1]}
    #print m
    
    #limb.move_to_joint_positions(n)
    

if __name__ == "__main__":
    main()

